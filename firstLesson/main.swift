//
//  main.swift
//  firstLesson
//
//  Created by M3 pro on 25/05/2025.
//

import Foundation

print("Hello, World!")

func main(){
    print("I'm Millioner")
}

main()

var myVar = "100 million"
var integer = 1
var float = 1.2
var string = "string"
var boolean = true
var boolean2 = false

print(myVar, integer, float, string, boolean, boolean2, separator: "\n")

let userAge = 23
let userName: String
userName = "michał"

print(userAge, userName)
                    
                        // МАТЕМАТИЧЕСКИЕ ОПЕРАТОРЫ
// остаток от деления
var residueOfDivision = userAge % 2
print("остаток от деления: ", residueOfDivision)
// на языке SWIFT обычное деление работает как деления без остатка на языке PYTHON
var divisionsWithoutRemainder = userAge/2
print("деления без остатка: ", divisionsWithoutRemainder)


                        // ЛОГИЧЕСКИЕ ОПЕРАТОРЫ ИЛИ ЛОГИЧЕСКИЕ ВЫРАЖЕНИЯ
// Логические операторы на языке SWIFT отличаются от операторов на языке PYTHON
// оператор "and" на языке SWIFT будет "&&", оператор "or" на языке SWIFT будет "||"

let age = 31
let name = "Timur"

if age == 31 && name == "Timur" {
    print("Да, это я")
} else {
    print("Нет, это не я дебил")
}

// Можно еще к переменной или константе присвоить результат операторов, при этом все можно написать на одной строке

let result = age == 31 && name == "Timur"
// результат будет булевое значение "true" и присвоится к константе result
print(result)

// еще одна вещь которого нет на языке python:
// "!" знак перед булевым знаечением возвращает противоположенное булевое значение
// где это может пригодиться? Например:

let result2 = age == 31 && !(name == "Timur")
print(result2)// здесь условие говорит: если возраст(age) равно 31 и имя(name) не равно "Timur". Вот так звучит и вот так можно использовать
// или же это значение можно сравнить вот с таким условием
let result3 = age == 31 && name != "Timur"
print(result3)
// результат одно и тоже

if age <= 30 {
    print("Ты еще молод, набирай опыта, совершенствуйся")
}
else if age > 30 && age < 36 {
    print("Развивайся максимально, не останавливайся, думай только на позитиве, ты скоро станешь миллионером!")
}
else {
    print("Ты живи на свое удоволствие, ты это заслужил")
}


                        // Получение информации с консоли

// Метод для получения информации с консоли readLine(),  python этот метод был input()

print("Укажите ваш возвраст: ")

let ageForYou = readLine() ?? "" // ?? "" обяснение этого внизу будет

print("Ваш возраст: ", ageForYou)


                        // Optional типы данных
// Это когда в конце названия типов данных стоит "?" знак. Например

var a: Int? = 1 // Это опциональный интегер можно назвать.

var b: String? = "Come On" // Это опциональная строка можно назвать.

//Основное отличие опциональных от обычных -- это они могут содержать значение nil, как на языке python None. Без опциональных типов нельзя указать nil, так как обычные типы данных не принимают значение nil
// Еще один немало важный момент с опционалами, это они не участвуют в математических операциях. Типо var a: Int? = 1 и var b: Int? = 2, a+b вот так нельзя, потому что в них может содержаться nil, а когда nil+nil сами понимаете так нельзя. Неважно то что мы указали цифры и тд, интерпретар это не различает то что присвоено по факту, когда у нас тип данных опциональное.
// Еще один момент с опционалами, переприсвоение значение переменных или констант, значие обычного типа данных к опционалу присвоить можно, а вот с опционала к обычному нельзя. Посмотрим на примере:
// var a: Int = 1 и var b: Int? = 3. b = a сработает и значение b = 1
// А вот наоборот нельзя, var a: Int = 1 и var b: Int? = 3, a = b выдаст ошибку, так как интерпретор не определят значение опционала.
// Но опционалов можно между собой сравнивать <,  >,  =

                        // Распаковка опционалов
// Распаковка опционалов нужно для проведения взаимодействия с ними (еще не знаю какие взаимодействия можно с ними осуществлять). Есть 4 вида распаковки:

// Явная безопасная распаковка
let firstNumber: Int = 9
let secondNumber: Int? = 8
let thirdNumber: Int? = nil

if let secondNumber{
    print("У вас получилось распаковать опционал и сложить: ", firstNumber + secondNumber)
} else {
    print("Константа bq пустая")
}

if let thirdNumber{
    print("У вас получилось распаковать опционал и сложить: ", firstNumber + thirdNumber)
} else {
    print("Константа cq пустая")
}
// На верхнем блоке кода идет распаковка с проверкой через оператор if. И всегда явная распаковка и безопасная распаковка идет через оператор if

// Явная НЕБЕЗОПАСНАЯ распаковка:

let fNumber: Int = 9
let sNumber: Int? = 8
let tNumber: Int? = nil

print(fNumber + sNumber!) // "!" вот этот знак вконце опционала означает "явная распаковка", но это считается не безопасным, так как нет проверки на валидность значения и в каких-то случаях программа может упасть из-за этого
print(fNumber+tNumber!)  // вот в этом случае программа в рантайме упадет, так как наша константа tNumber содержит значение nil. Вот знак ! называют программисты "палкой смерти"

// НЕЯВНАЯ и НЕБЕЗОПАСНАЯ распаковка
// Это не совсем то и распаковка на самом деле, но результат узнаешь при распаковке, поэтому я думаю его так назвали. Тут при обьвлении опционала используется НЕ вопросительный знак "?", а восклицательный знак "!". Это тоже будет считаться опционалом который может принят nil
let one: Int = 1
let two: Int! = 2
let three: Int! = nil

print(one + two) // компилятор не пишет никакой ошибки, так как мы обявили опционал через "!" знак.
print(two + three) // Но в этом случае программа упадет так как three содержит значение nil

// Следующий метод распаковки называется "Значение поумолчанию". Как это работает:

let one1: Int = 1
let two2: Int? = 2
let three3: Int? = nil

print(one1 + (two2 ?? 0)) // мы взяли под скобку опционал и ввели два вопросительных знака и 0, это выражение говорит: "Если есть какое-то значение в константе используй его, но если не будет значение, а точнее если там nil, подставь значение 0" Вместо 0 можно указать любое значение. Все это дело взяли под скобку для того чтобы сначала испольнился код внутри скобки, а не +, так как без скобки по приоритету знаков выполниться +, тогда программа упадет, для того чтобы код выполнился так как мы ожидаем надо в скобку загнать, тогда по приоритету исполнится сначала то что в скобке
